# System Design Fundamentals // 15 hours
- Foundations (high-level vs low-level design, requirements, constraints & trade-offs) // 5 hours  
- Architectural patterns (layered, microservices, serverless), identifying bottlenecks // 5 hours  
- Capacity planning & cost analysis (throughput, concurrency, simple calculations) // 5 hours  

# Communication & Networking // 15 hours
- Networking basics (TCP vs UDP, TLS/HTTPS, HTTP/2 & 3, load balancing, DNS) // 6 hours  
- Synchronous vs asynchronous comm (REST vs gRPC, websockets vs long polling) // 4 hours  
- CDN fundamentals (edge servers, caching, content invalidation), API gateways, reverse proxies // 5 hours  

# Database Basics (Relational & NoSQL) // 23 hours
- RDBMS vs NoSQL, schema design fundamentals, typical use cases // 4 hours  
- ACID vs BASE, transaction isolation levels, eventual consistency // 5 hours  
- Indexing strategies (B-Trees, hash indexes), query optimization // 5 hours  
- Normalization vs denormalization // 3 hours  
- Common NoSQL data models (key-value, document, column, graph) // 6 hours  

# Advanced Database Topics // 19 hours
- Replication (master-slave, leader-follower, multi-master), read replicas, failover // 6 hours  
- Sharding & partitioning (range, hash, consistent hashing), data distribution // 6 hours  
- CAP theorem in depth, distributed transactions & concurrency trade-offs // 7 hours

# Caching & Content Delivery // 17 hours
- Caching fundamentals (in-memory caching, Redis, Memcached), caching layers // 5 hours  
- Cache invalidation (write-through, write-back, TTL, LRU/LFU) // 5 hours  
- CDN deep dive (edge servers, static vs dynamic content, global traffic management) // 4 hours  
- Performance considerations & best practices // 3 hours

# Asynchronous Processing & Message Queues // 17 hours
- Message queues (pub-sub vs point-to-point), comparing Kafka, RabbitMQ, SQS // 6 hours  
- Delivery semantics (at-least-once, at-most-once, exactly-once), consumer groups // 5 hours  
- Eventual consistency in asynchronous pipelines, real-world use cases // 6 hours  

# Microservices Architecture // 19 hours
- Monolithic vs microservices evolution, domain-driven design basics // 6 hours  
- Inter-service communication (REST, gRPC, messaging), service discovery, gateways // 6 hours  
- Best practices, anti-patterns, operational overhead (deployment, testing) // 7 hours  

# Reliability & Resiliency Patterns // 13 hours
- Circuit breaker, retry/backoff, bulkhead, graceful degradation // 4 hours  
- Health checks, chaos engineering basics (fault injection) // 4 hours  
- Real-world scenarios (Netflix, Istio), designing for fault tolerance // 5 hours  

# Logging, Monitoring & Observability // 11 hours
- Centralized logging, log aggregation (ELK stack, Splunk), structured logs // 4 hours  
- Metrics & alerting (Prometheus, Grafana), time-series DB fundamentals // 3 hours  
- Distributed tracing (Jaeger, Zipkin), designing observability pipelines // 4 hours  

# Security & Compliance // 13 hours
- Authentication vs authorization (OAuth, JWT), single sign-on (SSO) // 4 hours  
- Encryption (at-rest, in-transit), rate limiting, WAF basics // 4 hours  
- Compliance (GDPR, PCI-DSS), secure design best practices // 5 hours  

# Performance & Scaling // 17 hours
- Performance testing (load vs stress), concurrency patterns, thread pools // 6 hours  
- Vertical vs horizontal scaling, capacity planning, cost optimization // 5 hours  
- Profiling & tuning (database, application-level), caching for performance // 6 hours  

# Containerization & Orchestration // 19 hours
- Docker fundamentals (images, containers, networking, Dockerfile best practices) // 6 hours  
- Kubernetes architecture (pods, deployments, services, HPA) // 7 hours  
- CI/CD pipelines (Jenkins, GitHub Actions), deployment strategies (rolling, canary) // 6 hours  

# Event-Driven Architecture // 14 hours
- Event sourcing vs CQRS, message brokers (Kafka, Pulsar) // 5 hours  
- Idempotent event handling, eventual consistency (sagas) // 5 hours  
- Orchestration vs choreography, advanced EDA patterns // 4 hours  

# Big Data & Analytics // 17 hours
- Batch processing (MapReduce, Hadoop, Spark), data lake vs data warehouse // 6 hours  
- Stream processing (Kafka Streams, Spark Streaming, Flink) // 6 hours  
- OLTP vs OLAP, ETL/ELT pipelines, large-scale analytics considerations // 5 hours  

# Real-Time Systems // 11 hours
- Low-latency design, concurrency, scheduling algorithms // 4 hours  
- Real-time use cases (gaming, trading), in-memory data grids // 3 hours  
- Key constraints (latency, jitter, resource management), trade-offs // 4 hours     